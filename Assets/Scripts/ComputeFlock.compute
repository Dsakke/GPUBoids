// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols
struct Boid
{
	float3 position;
	float3 velocity;
};

static const int threadGroupsSize = 1024;




RWStructuredBuffer<Boid> g_Boids;
float g_WorldSize;
float g_NeighborhoodRad;
int g_NrBoids;
float g_Acceleration;
float g_MaxSpeed;
float g_Seperation;
float g_Cohesion;
float g_Allignment;
float g_Wander;
float g_WanderCubeSize;
float g_WanderCubeDistance;

// https://gamedev.stackexchange.com/questions/149137/pseudo-random-number-generation-in-compute-shader
int3 RandomNumbers(uint3 id) // Not super great randomness but only really needs to look random
{
    int3 output = (float3) 0;
    output.x = (int) (sin(id.x * 71.01) * 500461564);
    output.y = (int) (cos(id.y * 53.7) * 1023467329);
    output.z = (int) (sin(id.z * 98.23) * 500461564);
    return output;

}

[numthreads(threadGroupsSize, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{	
	//register neighbors
    int nrNeighbors = 0;
    float3 averageAllignment = (float3)0;
    float3 averageCohesion = (float3) 0;
    float3 averageSeperation = (float3) 0;
    for (int idx = 0; idx < g_NrBoids; ++idx)
    {
        float3 otherPos = g_Boids[idx].position;
        float3 vecFromNeighbor = g_Boids[id.x].position - g_Boids[idx].position;
        float dist = length(vecFromNeighbor);
        if (dist < g_NeighborhoodRad) 
        {
            ++nrNeighbors;
            averageAllignment += g_Boids[idx].velocity;
            averageCohesion += g_Boids[idx].position;
            if(dist != 0.0f)
                averageSeperation += (vecFromNeighbor / dist) * (1 - (dist / g_NeighborhoodRad));
        }
    }

    // Wander Behaviour
    uint3 randomNumbers = RandomNumbers(id);
    float3 wanderPos = g_Boids[id.x].position;
    wanderPos.x = ((randomNumbers.x % g_WanderCubeSize * 2) - g_WanderCubeSize) / g_WanderCubeSize;
    wanderPos.y = ((randomNumbers.y % g_WanderCubeSize * 2) - g_WanderCubeSize) / g_WanderCubeSize;
    wanderPos.z = ((randomNumbers.z % g_WanderCubeSize * 2) - g_WanderCubeSize) / g_WanderCubeSize;
    float oriSpeed = length(g_Boids[id.x].velocity);
    float3 wander = (float3) 0;
    if(oriSpeed != 0)
    {
        wanderPos += g_Boids[id.x].position + (g_Boids[id.x].velocity / oriSpeed) * g_WanderCubeDistance;
        wander = normalize(wanderPos - g_Boids[id.x].position) * g_Wander;
    }
    
    averageAllignment /= nrNeighbors;
    averageCohesion /= nrNeighbors;
    float3 cohesion = averageCohesion - g_Boids[id.x].position;
    averageSeperation /= nrNeighbors;
    
    float allingmentLength = length(averageAllignment);
    if (allingmentLength != 0)
        averageAllignment = (averageAllignment / allingmentLength) * g_Allignment;
    
    cohesion = normalize(cohesion) * g_Cohesion;
    float seperationLength = length(averageSeperation);
    if (seperationLength > 0)
    {
        averageSeperation = (averageSeperation / seperationLength) * g_Seperation;      
    }
    
    float3 steering = averageAllignment + cohesion + averageSeperation + wander;
    float steeringLength = length(steering);
    if(steeringLength > 0)
    {
        g_Boids[id.x].velocity += steering / steeringLength * g_Acceleration;
    }
    
    float speed = length(g_Boids[id.x].velocity);
    if(speed > g_MaxSpeed)
    {
        g_Boids[id.x].velocity = (g_Boids[id.x].velocity / speed) * g_MaxSpeed;
    }
    g_Boids[id.x].position += g_Boids[id.x].velocity;
    
	// Keep boids in world, if the move out they get teleported to the other side
    if (g_Boids[id.x].position.x > g_WorldSize)
    {
        g_Boids[id.x].position.x = -g_WorldSize;
    }
    else if (g_Boids[id.x].position.x < -g_WorldSize)
    {
        g_Boids[id.x].position.x = g_WorldSize;
    }
	
    if (g_Boids[id.x].position.y > g_WorldSize)
    {
        g_Boids[id.x].position.y = -g_WorldSize;
    }
    else if (g_Boids[id.x].position.y < -g_WorldSize)
    {
        g_Boids[id.x].position.y = g_WorldSize;
    }
    
    if (g_Boids[id.x].position.z > g_WorldSize)
    {
        g_Boids[id.x].position.z = -g_WorldSize;
    }
    else if (g_Boids[id.x].position.z < -g_WorldSize)
    {
        g_Boids[id.x].position.z = g_WorldSize;
    }
}

