// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols
struct Boid
{
	float3 position;
	float3 velocity;
};

static const int threadGroupsSize = 1024;




RWStructuredBuffer<Boid> g_Boids;
float g_WorldSize;
float g_NeighborhoodRad;
int g_NrBoids;
float g_Acceleration;
float g_MaxSpeed;
float g_Seperation;
float g_Cohesion;
float g_Allignment;


[numthreads(threadGroupsSize, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{	
	//register neighbors
    int nrNeighbors = 0;
    float3 averageAllignment = (float3)0;
    float3 averageCohesion = (float3) 0;
    float3 averageSeperation = (float3) 0;
    for (int idx = 0; idx < g_NrBoids; ++idx)
    {
        float3 otherPos = g_Boids[idx].position;
        float3 vecFromNeighbor = g_Boids[id.x].position - g_Boids[idx].position;
        float dist = length(vecFromNeighbor);
        if (dist < g_NeighborhoodRad) 
        {
            ++nrNeighbors;
            averageAllignment += g_Boids[idx].velocity;
            averageCohesion += g_Boids[idx].position;
            if(dist != 0.0f)
                averageSeperation += (vecFromNeighbor / dist) * (1 - (dist / g_NeighborhoodRad));
        }
    }
    
    averageAllignment /= nrNeighbors;
    averageCohesion /= nrNeighbors;
    float3 cohesion = averageCohesion - g_Boids[id.x].position;
    averageSeperation /= nrNeighbors;

    if(nrNeighbors == 1) // if no neighbors boid does not move
    {
        return;
    }
    
    float allingmentLength = length(averageAllignment);
    if (allingmentLength != 0)
        averageAllignment = (averageAllignment / allingmentLength) * g_Allignment;
    
    cohesion = normalize(cohesion) * g_Cohesion;
    averageSeperation = normalize(averageSeperation) * g_Seperation;
    
    float3 steering = averageAllignment + cohesion + averageSeperation;
    float steeringLength = length(steering);
    if(length(steering) != 0)
        g_Boids[id.x].velocity = steering / steeringLength * g_MaxSpeed;
    g_Boids[id.x].position += g_Boids[id.x].velocity;
    
	// Keep boids in world, if the move out they get teleported to the other side
    if (g_Boids[id.x].position.x > g_WorldSize)
    {
        g_Boids[id.x].position.x = -g_WorldSize;
    }
    else if (g_Boids[id.x].position.x < -g_WorldSize)
    {
        g_Boids[id.x].position.x = g_WorldSize;
    }
	
    if (g_Boids[id.x].position.y > g_WorldSize)
    {
        g_Boids[id.x].position.y = -g_WorldSize;
    }
    else if (g_Boids[id.x].position.y < -g_WorldSize)
    {
        g_Boids[id.x].position.y = g_WorldSize;
    }
    
    if (g_Boids[id.x].position.z > g_WorldSize)
    {
        g_Boids[id.x].position.z = -g_WorldSize;
    }
    else if (g_Boids[id.x].position.z < -g_WorldSize)
    {
        g_Boids[id.x].position.z = g_WorldSize;
    }
}

